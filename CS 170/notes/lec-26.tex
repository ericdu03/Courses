\section{Quantum Algorithms}
\subsection{Brief History}
\begin{itemize}
	\item In the world of physics, there was a problem: we couldn't simulate quantum systems. What does that even mean?
	\item Suppose we have \( n \) electrons, each with spin \( \ket{\uparrow} \) or \( \ket{\downarrow} \). 
		This gives us a total of \( 2^{n} \) possible configurations. The fastest algorithm known at the time 
		was one that took \( O(2^{n}) \) time.
	\item Richard Feynman suggested in a 1981 talk that we could potentially build a computer out of 
		electrons, and instead of computing the quantum mechanics itself, we just let the electrons 
		simulate themselves.
	\item How powerful are quantum computers actually? Very powerful! A small list of algorithms that 
		are very powerful:
		\begin{itemize}
			\item Deutsch-Jozsa algorithm: solves the Deutsch-Josza problem
			\item Bernstein-Vazirani algorithm
			\item Simon's algorithm
			\item Shor's algorithm
			\item Grover's algorithm
		\end{itemize}
\end{itemize}
\subsection{Deutsch-Josza Problem}
\begin{itemize}
	\item Given an input function \( f: \{0, 1\} ^{n} \to [0, 1] \), the function is one of the following:
		\begin{enumerate}[label=\roman*)]
			\item \( f(x) = 0 \) for all \( x \) 
			\item \( f(x) = 1 \) for all \( x \) 
			\item \( f(x) = 0 \) for half of \( x \), and \( f(x) = 1 \) for the other half. 
		\end{enumerate}
	\item We proved that classical deterministic algorithms have to check at least \( 2^{n-1} +1 \) values 
		for \( f(x) \) to determine. This means that the algorithm runs in exponential time. However, 
		the quantum algorithm can do this process in \( O(n) \) time!
	\item There is also a very simple randomized algorithm for this: we can pick a subset of \( x \) at random,
		and this allows us to determine the identity of \( f(x) \) also fairly quickly.
	\item So this problem tells us the power of quantum computers over deterministic algorithms, but doesn't 
		show the power of quantum algorithms over random algorithms. 
\end{itemize}
\subsection{Bernstein-Vazirani Problem}
\begin{itemize}
	\item Given an input function \( f: \{0, 1\} ^{n} \to \{0, 1\}  \) that takes a subset of \( x \) and 
		adds the values up modulo 2, we want to figure out which bits were added in the sum.  
	\item Classically, we can look at all the possible configurations for \( f \), which would require 
		\( n+1 \) looks at \( f \). However, the quantum algorithm only needs to look at \( f \) once!
\end{itemize}
\subsection{Shor's Algorithm}
\begin{itemize}
	\item We know that if we have an \( n \)-digit number, the best classical algorithm factorizes a number in 
		\( O(e^{1.9 n^{1 / 3} \cdot \log(n)^{2 / 3}}) \), but Shor showed that we can factor numbers 
		in \( O(n^2) \) time on a quantum computer. 
	\item This is significant, because RSA encryption relies factoring large numbers and this algorithm basically 
		gives us a way to break that encryption scheme. 
\end{itemize}
\subsection{Grover's Algorithm}
\begin{itemize}
	\item This algorithm solves circuit-SAT in \( O(\sqrt{2} ^{n}) \) time on a quantum computer, wherea s
		a classical algorithm takes \( O(2^{n}) \) time. This also solves many other problems (just due to their 
		relationship to circuit-SAT).
\end{itemize}
\subsection{Speedups}
\begin{itemize}
	\item There are three main types of speedups:
		\begin{itemize}
			\item Shor-Type: these are exponentially faster than classical algorithms, but only work on 
				a very restricted subset of problems.
			\item Grover-Type: This speeds up things polynomially, but with the benefit that they work on a large
				number of problems. 
			\item Physics Simulation: Exponentially faster, but can only work for physics problems. 
		\end{itemize}
	\item One of the main reasons why quantum computers outperform classical ones is mainly because they can 
		compute very fast Fourier transforms, which are used everywhere in computation.  
	\item However, quantum computers are not able to solve NP-complete problems efficiently. 
\end{itemize}
